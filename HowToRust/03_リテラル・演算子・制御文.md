# リテラルと演算子と制御文
- リテラルとは、数値や文字そのものを指す。

## １．リテラル
### 数値リテラル
- 数値リテラルの一覧は、以下の通り。Rustでは、2進数を表現できることが特徴である。
    |数値リテラル|接頭辞|記述例|
    |--|--|--|
    |整数（10進数）|なし|123|
    |整数（16進数）|0x|0xffff|
    |整数（8進数）|0o|0o11|
    |整数（2進数）|0b|0b00001111|
    |整数（バイト）|b|b'A'、b'9'|
    |浮動小数点数|なし|1.23|
- また、型接尾辞も用意されており、数値に型を指定できる。型接尾辞の一覧は、以下の通り。
    |数値リテラル|接尾辞|記述例|
    |--|--|--|
    |整数<br>（バイトを除く）|i8, i16, i32, i64, i128, <br>isize, u8, u16, u32, u64, u128, usize|678_u32、0xaa_u8、0o77_u8、0b1111_0000|
    |浮動小数点数|f32, f64|1.23 9.87f32|

### 文字列リテラル
- 文字列リテラルは、文字列を表し、Rustでは、文字列型というのはない。
- 文字列リテラルは、ダブルクォーテーション（”）で囲えばいいだけ。

### 演算子
- Rustで扱う演算子は、C/C++とほほ同じ。
- ただし、インクリメント演算子（++）とデクリメント演算子（--）はない。

### 条件分岐（if。else、else if）
- 構文は、C/C++とほぼ一緒で、以下のような形。ここで、条件式は（）でくくらないことに注意すること。
```
        if 条件式 {
            処理１;
        } else if 条件式 {
            処理２;
        } else {
            処理３;
        }
```
- 以下のような構文でif文を使って値を返すこともできる。下記の例のコメントに注意すること。
```
        let x = if 条件式 {
            値１            // セミコロンはなくていい。
        } else if 条件式 {
            値２            // セミコロンはなくていい。
        } else {
            値３            // セミコロンはなくていい。
        };              // 式の終わりなので、セミコロンがいる。
```
- 条件式は、その結果が必ず論理値のbool型となるように記述すること。C/C++では、0か0以外で判定していたが、これがバグの要因となることもあったので、Rustでは厳格化されている。

### 条件分岐（match）
- C/C++のswitch文に似ている。構文は、以下の通り。
- match文は、if文と同様に、値を返すことができる。
```
        match 変数 {
            '〇' => {処理１; 処理２; ・・・},　// 単一パターンマッチング
            ‘〇’ | ‘△’ => {・・・},　// 複数パターンマッチング
            ‘〇’ ..= '□'　=> {・・・},　// 範囲パターンマッチング
            _=> {・・・}　// いずれもマッチしない場合
        }
```
- 上記の構文で、処理の部分{ }にカンマ”,”はなくていいが、処理分が1つの場合で{ }を使わなかったら、カンマ”,”は必要である。
- 変数が、複数のパターンにマッチしてしまうようなコードはコンパイル時に警告がでる。実行結果としては、最初にマッチしたパターンの処理がなされる。

### 繰り返し（while）
- while文は、条件式がtrueの間、ブロック内の処理が繰り返される。構文は、以下の通り。
```
        while 条件式 {
            処理１
            処理２
            ・・・
        }
```
- while文もif文と同様に、条件式に”()”は必要ない。
- whileは、ifと違って、whileの結果を変数に返すことはできない。

### 繰り返し（for）
- for文は、C/C++のfor文とは全く異なることに注意すること。Javaなどのforeach文のようなもの。
- 配列などの要素を取り出して、それを使って処理する、ということを繰り返す。
- 例として、以下のように、配列の要素を取り出して1つずつ表示させる例を参考にすること。
```
        fn main() {
            let x = [10,20,30,40,50];

            for y in x.iter() {
                println!("{}です", y);
            }
        }
```
- forもwhileと同様に、forの結果を変数に返すことはできない。

### 繰り返し（loop）
- 無限ループする文で、構文は、以下の通り。
```
        loop {
            処理１
            処理２
            ・・・
        }
```
- loopを止めるには、[Ctrl]＋[C]で止めるか、break文を使って何らかの条件で止めるようにする。
- loop文もbreak文も結果を変数に返すことが可能である。
